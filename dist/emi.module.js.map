{"version":3,"file":"emi.module.js","sources":["../src/Emitter.ts","../src/UniqueEmitter.ts"],"sourcesContent":["import { EventType, EventListener, EventListenerId, Events } from './types';\n\nfunction getOrCreateEventData(events: Map<EventType, EventData>, type: EventType) {\n  let eventData = events.get(type);\n  if (!eventData) {\n    eventData = new EventData();\n    events.set(type, eventData);\n  }\n  return eventData;\n}\n\nclass EventData {\n  idMap: Map<EventListenerId, EventListener>;\n  fnMap: Map<EventListener, Set<EventListenerId>>;\n  onceList: Set<EventListenerId>;\n  emitList: EventListener[] | null;\n\n  constructor() {\n    this.idMap = new Map();\n    this.fnMap = new Map();\n    this.onceList = new Set();\n    this.emitList = null;\n  }\n\n  addListener(listener: EventListener, once?: boolean): EventListenerId {\n    // Get existing listener ids for the listener.\n    let listenerIds = this.fnMap.get(listener);\n\n    // Create listener id list if needed.\n    if (!listenerIds) {\n      listenerIds = new Set();\n      this.fnMap.set(listener, listenerIds);\n    }\n\n    // Create unique listener id. A symbol is optimal for this case since\n    // it's always unique.\n    const listenerId = Symbol();\n\n    // Store listener and listener id.\n    listenerIds.add(listenerId);\n    this.idMap.set(listenerId, listener);\n\n    // Add to once list if needed.\n    if (once) {\n      this.onceList.add(listenerId);\n    }\n\n    // Add to emit list if needed. We can safely add new listeners to the\n    // end of emit list even if it is currently looping, but we can't remove\n    // items from it.\n    this.emitList?.push(listener);\n\n    return listenerId;\n  }\n\n  deleteListener(listenerId: EventListenerId) {\n    if (!this.idMap.has(listenerId)) return;\n\n    const listener = this.idMap.get(listenerId) as EventListener;\n    const listenerIds = this.fnMap.get(listener) as Set<EventListenerId>;\n\n    this.onceList.delete(listenerId);\n    this.idMap.delete(listenerId);\n    listenerIds.delete(listenerId);\n\n    if (!listenerIds.size) {\n      this.fnMap.delete(listener);\n    }\n\n    this.emitList = null;\n  }\n\n  deleteListeners(listener: EventListener) {\n    const listenerIds = this.fnMap.get(listener);\n    if (!listenerIds) return;\n\n    for (const listenerId of listenerIds) {\n      this.onceList.delete(listenerId);\n      this.idMap.delete(listenerId);\n    }\n\n    this.fnMap.delete(listener);\n    this.emitList = null;\n  }\n}\n\nexport class Emitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    return getOrCreateEventData(this._events, type).addListener(listener);\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    return getOrCreateEventData(this._events, type).addListener(listener, true);\n  }\n\n  off<EventType extends keyof T>(\n    type?: EventType,\n    listener?: T[EventType] | EventListenerId\n  ): void {\n    // If type is undefined, let's remove all listeners from the emitter.\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    // If listener is undefined, let's remove all listeners from the type.\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    // Let's get the event data for the listener.\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    // If listener is a function let's delete all instances of it from the\n    // event type.\n    if (typeof listener === 'function') {\n      eventData.deleteListeners(listener);\n    }\n    // If the listener is a listener id let's delete the specific listener.\n    else {\n      eventData.deleteListener(listener);\n    }\n\n    // If the event type doesn't have any listeners left let's delete it.\n    if (!eventData.idMap.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, ...args: Parameters<T[EventType]>): void {\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    const { idMap, onceList } = eventData;\n\n    // Return early if there are no listeners.\n    if (!idMap.size) return;\n\n    // Get the listeners for this emit process. If we have cached listeners\n    // in event data (emit list) we use that, and fallback to cloning the\n    // listeners from the id map. The listeners we loop should be just a\n    // simple array for best performance. Cloning the listeners is expensive,\n    // which is why we do it only when absolutely needed.\n    const listeners = eventData.emitList || [...idMap.values()];\n\n    // Delete all once listeners _after_ the clone operation. We don't want\n    // to touch the cloned/cached listeners here, but only the \"live\" data.\n    if (onceList.size) {\n      // If once list has all the listener ids we can just delete the event\n      // and be done with it.\n      if (onceList.size === idMap.size) {\n        this._events.delete(type);\n      }\n      // Otherwise, let's delete the once listeners one by one.\n      else {\n        for (const listenerId of onceList) {\n          eventData.deleteListener(listenerId);\n        }\n      }\n    }\n    // In case there are no once listeners we can cache the listeners array.\n    else {\n      eventData.emitList = listeners;\n    }\n\n    // Execute the current event listeners. Basic for loop for the win. Here\n    // it's important to cache the listeners' length as the listeners array may\n    // grow during execution (but not shrink).\n    let i = 0;\n    let l = listeners.length;\n    for (; i < l; i++) {\n      listeners[i](...(args as any[]));\n    }\n  }\n}\n","import { EventType, EventListener, Events } from './types';\n\ninterface EventData {\n  listeners: Set<EventListener>;\n  onceListeners: Set<EventListener>;\n  emitList: EventListener[] | null;\n}\n\nfunction getOrCreateEventData(events: Map<EventType, EventData>, type: EventType) {\n  let eventData = events.get(type);\n  if (!eventData) {\n    eventData = {\n      listeners: new Set(),\n      onceListeners: new Set(),\n      emitList: null,\n    };\n    events.set(type, eventData);\n  }\n  return eventData;\n}\n\nexport class UniqueEmitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): T[EventType] {\n    const { listeners, emitList } = getOrCreateEventData(this._events, type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      emitList?.push(listener);\n    }\n    return listener;\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): T[EventType] {\n    const { listeners, onceListeners, emitList } = getOrCreateEventData(this._events, type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      onceListeners.add(listener);\n      emitList?.push(listener);\n    }\n    return listener;\n  }\n\n  off<EventType extends keyof T>(type?: EventType, listener?: T[EventType]): void {\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    eventData.listeners.delete(listener);\n    eventData.onceListeners.delete(listener);\n    eventData.emitList = null;\n\n    if (!eventData.listeners.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, data: Parameters<T[EventType]>[0]): void {\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    const { listeners, onceListeners, emitList } = eventData;\n\n    if (!listeners.size) return;\n\n    const cachedListeners = emitList || [...listeners];\n\n    if (onceListeners.size) {\n      if (onceListeners.size === listeners.size) {\n        this._events.delete(type);\n      } else {\n        for (const listener of onceListeners) {\n          listeners.delete(listener);\n        }\n        onceListeners.clear();\n        eventData.emitList = null;\n      }\n    } else {\n      eventData.emitList = cachedListeners;\n    }\n\n    let i = 0;\n    let l = cachedListeners.length;\n    for (; i < l; i++) {\n      cachedListeners[i](data);\n    }\n  }\n}\n"],"names":["getOrCreateEventData","events","type","eventData","get","EventData","set","idMap","fnMap","this","onceList","emitList","Map","Set","addListener","listener","once","_this$emitList","listenerIds","listenerId","Symbol","add","push","deleteListener","has","size","deleteListeners","_step","_iterator","done","value","Emitter","_events","_proto2","prototype","on","off","undefined","clear","emit","listeners","values","_step2","_iterator2","i","l","length","apply","slice","call","arguments","onceListeners","UniqueEmitter","_getOrCreateEventData","_proto","_getOrCreateEventData2","data","cachedListeners","_createForOfIteratorHelperLoose"],"mappings":"szBAEA,SAASA,EAAqBC,EAAmCC,GAC/D,IAAIC,EAAYF,EAAOG,IAAIF,GAK3B,OAJKC,IACHA,EAAY,IAAIE,EAChBJ,EAAOK,IAAIJ,EAAMC,IAEZA,MAGHE,eAMJ,WAAA,SAAAA,IALAE,KAAAA,kBACAC,WAIA,EAAAC,KAHAC,cAGA,EAAAD,KAFAE,cAEA,EACEF,KAAKF,MAAQ,IAAIK,IACjBH,KAAKD,MAAQ,IAAII,IACjBH,KAAKC,SAAW,IAAIG,IACpBJ,KAAKE,SAAW,SAGlBG,EAAAA,EAAAA,iBAAAA,EAAAA,YAAA,SAAYC,EAAyBC,GAAc,IAAAC,EAE7CC,EAAcT,KAAKD,MAAMJ,IAAIW,GAG5BG,IACHA,EAAc,IAAIL,IAClBJ,KAAKD,MAAMF,IAAIS,EAAUG,IAK3B,IAAMC,EAAaC,SAgBnB,OAbAF,EAAYG,IAAIF,GAChBV,KAAKF,MAAMD,IAAIa,EAAYJ,GAGvBC,GACFP,KAAKC,SAASW,IAAIF,GAMpB,OAAAF,EAAAR,KAAKE,WAALM,EAAeK,KAAKP,GAEbI,KAGTI,eAAA,SAAeJ,GACb,GAAKV,KAAKF,MAAMiB,IAAIL,GAApB,CAEA,IAAMJ,EAAWN,KAAKF,MAAMH,IAAIe,GAC1BD,EAAcT,KAAKD,MAAMJ,IAAIW,GAEnCN,KAAKC,SAAgBS,OAAAA,GACrBV,KAAKF,MAAaY,OAAAA,GAClBD,EAAA,OAAmBC,GAEdD,EAAYO,MACfhB,KAAKD,aAAaO,GAGpBN,KAAKE,SAAW,SAGlBe,gBAAA,SAAgBX,GACd,IAAMG,EAAcT,KAAKD,MAAMJ,IAAIW,GACnC,GAAKG,EAAL,CAEA,QAAAS,MAAyBT,KAAzBS,EAAAC,KAAAC,MAAsC,CAA3BV,IAAAA,EACTQ,EAAAG,MAAArB,KAAKC,SAAL,OAAqBS,GACrBV,KAAKF,aAAaY,GAGpBV,KAAKD,MAAaO,OAAAA,GAClBN,KAAKE,SAAW,SAjElB,GAqEWoB,eAAb,WAGE,aAFUC,KAAAA,aAGR,EAAAvB,KAAKuB,QAAU,IAAIpB,IAJvB,IAAAqB,EAAAF,EAAAG,UAAA,OAAAD,EAOEE,GAAA,SAA8BjC,EAAiBa,GAC7C,OAAOf,EAAqBS,KAAKuB,QAAS9B,GAAMY,YAAYC,IAG9DC,EAAAA,KAAA,SAAgCd,EAAiBa,GAC/C,OAAOf,EAAqBS,KAAKuB,QAAS9B,GAAMY,YAAYC,GAAU,IAGxEqB,EAAAA,IAAA,SACElC,EACAa,GAGA,QAAasB,IAATnC,EAMJ,QAAiBmC,IAAbtB,EAAJ,CAMA,IAAMZ,EAAYM,KAAKuB,QAAQ5B,IAAIF,GAC9BC,IAImB,mBAAbY,EACTZ,EAAUuB,gBAAgBX,GAI1BZ,EAAUoB,eAAeR,GAItBZ,EAAUI,MAAMkB,MACnBhB,KAAKuB,QAAL,OAAoB9B,SApBpBO,KAAKuB,QAAL,OAAoB9B,QANpBO,KAAKuB,QAAQM,SArBnBL,EAmDEM,KAAA,SAAgCrC,GAC9B,IAAMC,EAAYM,KAAKuB,QAAQ5B,IAAIF,GACnC,GAAKC,EAAL,CAEA,IAAQI,EAAoBJ,EAApBI,MAAOG,EAAaP,EAAbO,SAGf,GAAKH,EAAMkB,KAAX,CAOA,IAAMe,EAAYrC,EAAUQ,oBAAgBJ,EAAMkC,UAIlD,GAAI/B,EAASe,KAGX,GAAIf,EAASe,OAASlB,EAAMkB,KAC1BhB,KAAKuB,QAAL,OAAoB9B,QAIpB,IAAyBQ,IAAUgC,EAAVhC,EAAAA,EAAAA,KAAUgC,EAAAC,KAAAd,MAAA,CAAA,IAAxBV,UACThB,EAAUoB,eAAeJ,QAM7BhB,EAAUQ,SAAW6B,EAQvB,IAFA,IAAII,EAAI,EACJC,EAAIL,EAAUM,OACXF,EAAIC,EAAGD,IACZJ,EAAUI,GAAVG,MAAAP,EAAS,GAAAQ,MAAAC,KAAAC,UAAA,OA7FfnB,EAAA,GC9EA,SAAS/B,EAAqBC,EAAmCC,GAC/D,IAAIC,EAAYF,EAAOG,IAAIF,GAS3B,OARKC,IACHA,EAAY,CACVqC,UAAW,IAAI3B,IACfsC,cAAe,IAAItC,IACnBF,SAAU,MAEZV,EAAOK,IAAIJ,EAAMC,IAEZA,EAGIiD,IAAAA,eAAb,WAGE,SAAAA,IAAA3C,KAFUuB,aAEV,EACEvB,KAAKuB,QAAU,IAAIpB,IAJvB,kBAAA,SAOEuB,GAAA,SAA8BjC,EAAiBa,GAC7C,IAAAsC,EAAgCrD,EAAqBS,KAAKuB,QAAS9B,GAA3DsC,EAARa,EAAQb,UAAW7B,EAAAA,EAAAA,SAKnB,OAJK6B,EAAUhB,IAAIT,KACjByB,EAAUnB,IAAIN,GACd,MAAAJ,GAAAA,EAAUW,KAAKP,IAEVA,GAbXuC,EAgBEtC,KAAA,SAAgCd,EAAiBa,GAC/C,IAA+Cf,EAAAA,EAAqBS,KAAKuB,QAAS9B,GAA1EsC,EAAAA,EAAAA,UAAWW,EAAAA,EAAAA,cAAexC,EAAlC4C,EAAkC5C,SAMlC,OALK6B,EAAUhB,IAAIT,KACjByB,EAAUnB,IAAIN,GACdoC,EAAc9B,IAAIN,GAClB,MAAAJ,GAAAA,EAAUW,KAAKP,IAEVA,GAGTqB,EAAAA,IAAA,SAA+BlC,EAAkBa,GAC/C,QAAasB,IAATnC,EAKJ,QAAiBmC,IAAbtB,EAAJ,CAKA,IAAMZ,EAAYM,KAAKuB,QAAQ5B,IAAIF,GAC9BC,IAELA,EAAUqC,UAAV,OAA2BzB,GAC3BZ,EAAUgD,cAAqBpC,OAAAA,GAC/BZ,EAAUQ,SAAW,KAEhBR,EAAUqC,UAAUf,MACvBhB,KAAKuB,QAAe9B,OAAAA,SAZpBO,KAAKuB,QAAL,OAAoB9B,QALpBO,KAAKuB,QAAQM,SA5BnBgB,EAiDEf,KAAA,SAAgCrC,EAAiBsD,GAC/C,IAAMrD,EAAYM,KAAKuB,QAAQ5B,IAAIF,GACnC,GAAKC,EAAL,CAEA,IAAQqC,EAAuCrC,EAAvCqC,UAAWW,EAA4BhD,EAA5BgD,cAEnB,GAAKX,EAAUf,KAAf,CAEA,IAAMgC,EAJyCtD,EAAbQ,UAIM6B,GAAAA,OAAAA,GAExC,GAAIW,EAAc1B,KAChB,GAAI0B,EAAc1B,OAASe,EAAUf,KACnChB,KAAKuB,QAAe9B,OAAAA,OACf,CACL,IAAA,IAAAyB,EAAAC,EAAA8B,EAAuBP,KAAvBxB,EAAAC,KAAAC,MACEW,EAAA,OAAAA,EAAAA,OAEFW,EAAcb,QACdnC,EAAUQ,SAAW,UAGvBR,EAAUQ,SAAW8C,EAKvB,IAFA,IAAIb,EAAI,EACJC,EAAIY,EAAgBX,OACjBF,EAAIC,EAAGD,IACZa,EAAgBb,GAAGY,MA5EzBJ,EAAA"}