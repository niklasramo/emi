{"version":3,"file":"emi.modern.js","sources":["../src/Emitter.ts","../src/UniqueEmitter.ts"],"sourcesContent":["import { EventType, EventListener, EventListenerId, Events } from './types';\n\nclass EventData {\n  idMap: Map<EventListenerId, EventListener>;\n  fnMap: Map<Function, Set<EventListenerId>>;\n  onceList: Set<EventListenerId>;\n  emitList: EventListener[] | null;\n\n  constructor() {\n    this.idMap = new Map();\n    this.fnMap = new Map();\n    this.onceList = new Set();\n    this.emitList = null;\n  }\n\n  addListener(listener: EventListener, once?: boolean): EventListenerId {\n    // Create unique listener id, a symbol is optimal for this case since we\n    // need uid, but not uuid.\n    const listenerId = Symbol();\n\n    // Get/Create existing listener ids for the listener.\n    let listenerIds = this.fnMap.get(listener);\n    if (!listenerIds) {\n      listenerIds = new Set();\n      this.fnMap.set(listener, listenerIds);\n    }\n\n    // Store listener and listener id.\n    listenerIds.add(listenerId);\n    this.idMap.set(listenerId, listener);\n\n    // Add to once list if needed.\n    if (once) {\n      this.onceList.add(listenerId);\n    }\n\n    // Add to emit list if needed.\n    this.emitList?.push(listener);\n\n    return listenerId;\n  }\n\n  deleteListener(listenerId: EventListenerId) {\n    if (!this.idMap.has(listenerId)) return;\n\n    const listener = this.idMap.get(listenerId) as EventListener;\n    const listenerIds = this.fnMap.get(listener) as Set<EventListenerId>;\n\n    this.onceList.delete(listenerId);\n    this.idMap.delete(listenerId);\n    listenerIds.delete(listenerId);\n\n    if (!listenerIds.size) {\n      this.fnMap.delete(listener);\n    }\n\n    this.emitList = null;\n  }\n\n  deleteListeners(listener: EventListener) {\n    const listenerIds = this.fnMap.get(listener);\n    if (!listenerIds) return;\n\n    for (const listenerId of listenerIds) {\n      this.onceList.delete(listenerId);\n      this.idMap.delete(listenerId);\n    }\n\n    this.fnMap.delete(listener);\n    this.emitList = null;\n  }\n}\n\nexport class Emitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    // Get event data.\n    let eventData = this._events.get(type);\n\n    // Create event data if it does not exist yet.\n    if (!eventData) {\n      eventData = new EventData();\n      this._events.set(type, eventData);\n    }\n\n    // Add the listener to the event data and return the listener id.\n    return eventData.addListener(listener);\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    // Get event data.\n    let eventData = this._events.get(type);\n\n    // Create event data if it does not exist yet.\n    if (!eventData) {\n      eventData = new EventData();\n      this._events.set(type, eventData);\n    }\n\n    // Add the listener to the event (with once flag) data and return the\n    // listener id.\n    return eventData.addListener(listener, true);\n  }\n\n  off<EventType extends keyof T>(\n    type?: EventType,\n    listener?: T[EventType] | EventListenerId\n  ): void {\n    // If type is undefined, let's remove all listeners from the emitter.\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    // If listener is undefined, let's remove all listeners from the type.\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    // Let's get the event data for the listener.\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    // If listener is a function let's delete all instances of it from the\n    // event type.\n    if (typeof listener === 'function') {\n      eventData.deleteListeners(listener);\n    }\n    // If the listener is a listener id let's delete the specific listener.\n    else {\n      eventData.deleteListener(listener);\n    }\n\n    // If the event type doesn't have any listeners left let's delete it.\n    if (!eventData.idMap.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, ...args: Parameters<T[EventType]>): void {\n    const eventData = this._events.get(type);\n    if (!eventData || !eventData.idMap.size) return;\n\n    // Get the listeners for this emit process. If we have cached listeners\n    // in event data (emit list) we use that, and fallback to cloning the\n    // listeners from the id map. The listeners we loop should be just a\n    // simple array for best performance. Cloning the listeners is expensive,\n    // which is why we do it only when absolutely needed.\n    const listeners = eventData.emitList || [...eventData.idMap.values()];\n\n    // Cache the listeners.\n    eventData.emitList = listeners;\n\n    // Delete all once listeners _after_ the clone operation. We don't want\n    // to touch the cloned/cached listeners here, but only the \"live\" data.\n    // Note the listeners will be uncached from event data via\n    // \"eventData.deleteListener\" method in case there are once listeners,\n    // intentionally.\n    if (eventData.onceList.size) {\n      for (const listenerId of eventData.onceList) {\n        eventData.deleteListener(listenerId);\n      }\n    }\n\n    // Execute the current event listeners. Basic for loop for the win. Here\n    // it is important to cache the listeners' length for functionality's sake\n    // as the listeners array may grow during execution (but not shrink).\n    let i = 0;\n    let l = listeners.length;\n    for (; i < l; i++) {\n      listeners[i](...(args as any[]));\n    }\n  }\n}\n","import { EventType, EventListener, Events } from './types';\n\ninterface EventData {\n  listeners: Set<EventListener>;\n  onceListeners: Set<EventListener>;\n  emitList: EventListener[] | null;\n}\n\nexport class UniqueEmitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  protected _createEventData<EventType extends keyof T>(type: EventType): EventData {\n    const eventData: EventData = {\n      listeners: new Set(),\n      onceListeners: new Set(),\n      emitList: null,\n    };\n    this._events.set(type, eventData);\n    return eventData;\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): void {\n    const { listeners, emitList } = this._events.get(type) || this._createEventData(type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      emitList?.push(listener);\n    }\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): void {\n    const { listeners, onceListeners, emitList } =\n      this._events.get(type) || this._createEventData(type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      onceListeners.add(listener);\n      emitList?.push(listener);\n    }\n  }\n\n  off<EventType extends keyof T>(type?: EventType, listener?: T[EventType]): void {\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    eventData.listeners.delete(listener);\n    eventData.onceListeners.delete(listener);\n    eventData.emitList = null;\n\n    if (!eventData.listeners.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, data: Parameters<T[EventType]>[0]): void {\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    const listeners = eventData.emitList || [...eventData.listeners];\n\n    if (eventData.onceListeners.size) {\n      eventData.emitList = null;\n      for (const listener of eventData.onceListeners) {\n        eventData.listeners.delete(listener);\n      }\n      eventData.onceListeners.clear();\n    } else {\n      eventData.emitList = listeners;\n    }\n\n    let i = 0;\n    let l = listeners.length;\n    for (; i < l; i++) {\n      listeners[i](data);\n    }\n  }\n}\n"],"names":["EventData","constructor","idMap","fnMap","onceList","emitList","this","Map","Set","addListener","listener","once","_this$emitList","listenerId","Symbol","listenerIds","get","set","add","push","deleteListener","has","delete","size","deleteListeners","Emitter","_events","on","type","eventData","off","undefined","clear","emit","args","listeners","values","i","l","length","UniqueEmitter","_createEventData","onceListeners","data"],"mappings":"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"}