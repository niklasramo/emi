{"version":3,"file":"emi.modern.js","sources":["../src/Emitter.ts","../src/UniqueEmitter.ts"],"sourcesContent":["import { EventType, EventListener, EventListenerId, Events } from './types';\n\nfunction getOrCreateEventData(events: Map<EventType, EventData>, type: EventType) {\n  let eventData = events.get(type);\n  if (!eventData) {\n    eventData = new EventData();\n    events.set(type, eventData);\n  }\n  return eventData;\n}\n\nclass EventData {\n  idMap: Map<EventListenerId, EventListener>;\n  fnMap: Map<EventListener, Set<EventListenerId>>;\n  onceList: Set<EventListenerId>;\n  emitList: EventListener[] | null;\n\n  constructor() {\n    this.idMap = new Map();\n    this.fnMap = new Map();\n    this.onceList = new Set();\n    this.emitList = null;\n  }\n\n  addListener(listener: EventListener, once?: boolean): EventListenerId {\n    // Get existing listener ids for the listener.\n    let listenerIds = this.fnMap.get(listener);\n\n    // Create listener id list if needed.\n    if (!listenerIds) {\n      listenerIds = new Set();\n      this.fnMap.set(listener, listenerIds);\n    }\n\n    // Create unique listener id. A symbol is optimal for this case since\n    // it's always unique.\n    const listenerId = Symbol();\n\n    // Store listener and listener id.\n    listenerIds.add(listenerId);\n    this.idMap.set(listenerId, listener);\n\n    // Add to once list if needed.\n    if (once) {\n      this.onceList.add(listenerId);\n    }\n\n    // Add to emit list if needed. We can safely add new listeners to the\n    // end of emit list even if it is currently looping, but we can't remove\n    // items from it.\n    this.emitList?.push(listener);\n\n    return listenerId;\n  }\n\n  deleteListener(listenerId: EventListenerId) {\n    if (!this.idMap.has(listenerId)) return;\n\n    const listener = this.idMap.get(listenerId) as EventListener;\n    const listenerIds = this.fnMap.get(listener) as Set<EventListenerId>;\n\n    this.onceList.delete(listenerId);\n    this.idMap.delete(listenerId);\n    listenerIds.delete(listenerId);\n\n    if (!listenerIds.size) {\n      this.fnMap.delete(listener);\n    }\n\n    this.emitList = null;\n  }\n\n  deleteListeners(listener: EventListener) {\n    const listenerIds = this.fnMap.get(listener);\n    if (!listenerIds) return;\n\n    for (const listenerId of listenerIds) {\n      this.onceList.delete(listenerId);\n      this.idMap.delete(listenerId);\n    }\n\n    this.fnMap.delete(listener);\n    this.emitList = null;\n  }\n}\n\nexport class Emitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    return getOrCreateEventData(this._events, type).addListener(listener);\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): EventListenerId {\n    return getOrCreateEventData(this._events, type).addListener(listener, true);\n  }\n\n  off<EventType extends keyof T>(\n    type?: EventType,\n    listener?: T[EventType] | EventListenerId\n  ): void {\n    // If type is undefined, let's remove all listeners from the emitter.\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    // If listener is undefined, let's remove all listeners from the type.\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    // Let's get the event data for the listener.\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    // If listener is a function let's delete all instances of it from the\n    // event type.\n    if (typeof listener === 'function') {\n      eventData.deleteListeners(listener);\n    }\n    // If the listener is a listener id let's delete the specific listener.\n    else {\n      eventData.deleteListener(listener);\n    }\n\n    // If the event type doesn't have any listeners left let's delete it.\n    if (!eventData.idMap.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, ...args: Parameters<T[EventType]>): void {\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    const { idMap, onceList } = eventData;\n\n    // Return early if there are no listeners.\n    if (!idMap.size) return;\n\n    // Get the listeners for this emit process. If we have cached listeners\n    // in event data (emit list) we use that, and fallback to cloning the\n    // listeners from the id map. The listeners we loop should be just a\n    // simple array for best performance. Cloning the listeners is expensive,\n    // which is why we do it only when absolutely needed.\n    const listeners = eventData.emitList || [...idMap.values()];\n\n    // Delete all once listeners _after_ the clone operation. We don't want\n    // to touch the cloned/cached listeners here, but only the \"live\" data.\n    if (onceList.size) {\n      // If once list has all the listener ids we can just delete the event\n      // and be done with it.\n      if (onceList.size === idMap.size) {\n        this._events.delete(type);\n      }\n      // Otherwise, let's delete the once listeners one by one.\n      else {\n        for (const listenerId of onceList) {\n          eventData.deleteListener(listenerId);\n        }\n      }\n    }\n    // In case there are no once listeners we can cache the listeners array.\n    else {\n      eventData.emitList = listeners;\n    }\n\n    // Execute the current event listeners. Basic for loop for the win. Here\n    // it's important to cache the listeners' length as the listeners array may\n    // grow during execution (but not shrink).\n    let i = 0;\n    let l = listeners.length;\n    for (; i < l; i++) {\n      listeners[i](...(args as any[]));\n    }\n  }\n}\n","import { EventType, EventListener, Events } from './types';\n\ninterface EventData {\n  listeners: Set<EventListener>;\n  onceListeners: Set<EventListener>;\n  emitList: EventListener[] | null;\n}\n\nfunction getOrCreateEventData(events: Map<EventType, EventData>, type: EventType) {\n  let eventData = events.get(type);\n  if (!eventData) {\n    eventData = {\n      listeners: new Set(),\n      onceListeners: new Set(),\n      emitList: null,\n    };\n    events.set(type, eventData);\n  }\n  return eventData;\n}\n\nexport class UniqueEmitter<T extends Events> {\n  protected _events: Map<EventType, EventData>;\n\n  constructor() {\n    this._events = new Map();\n  }\n\n  on<EventType extends keyof T>(type: EventType, listener: T[EventType]): T[EventType] {\n    const { listeners, emitList } = getOrCreateEventData(this._events, type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      emitList?.push(listener);\n    }\n    return listener;\n  }\n\n  once<EventType extends keyof T>(type: EventType, listener: T[EventType]): T[EventType] {\n    const { listeners, onceListeners, emitList } = getOrCreateEventData(this._events, type);\n    if (!listeners.has(listener)) {\n      listeners.add(listener);\n      onceListeners.add(listener);\n      emitList?.push(listener);\n    }\n    return listener;\n  }\n\n  off<EventType extends keyof T>(type?: EventType, listener?: T[EventType]): void {\n    if (type === undefined) {\n      this._events.clear();\n      return;\n    }\n\n    if (listener === undefined) {\n      this._events.delete(type);\n      return;\n    }\n\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    eventData.listeners.delete(listener);\n    eventData.onceListeners.delete(listener);\n    eventData.emitList = null;\n\n    if (!eventData.listeners.size) {\n      this._events.delete(type);\n    }\n  }\n\n  emit<EventType extends keyof T>(type: EventType, data: Parameters<T[EventType]>[0]): void {\n    const eventData = this._events.get(type);\n    if (!eventData) return;\n\n    const { listeners, onceListeners, emitList } = eventData;\n\n    if (!listeners.size) return;\n\n    const cachedListeners = emitList || [...listeners];\n\n    if (onceListeners.size) {\n      if (onceListeners.size === listeners.size) {\n        this._events.delete(type);\n      } else {\n        for (const listener of onceListeners) {\n          listeners.delete(listener);\n        }\n        onceListeners.clear();\n        eventData.emitList = null;\n      }\n    } else {\n      eventData.emitList = cachedListeners;\n    }\n\n    let i = 0;\n    let l = cachedListeners.length;\n    for (; i < l; i++) {\n      cachedListeners[i](data);\n    }\n  }\n}\n"],"names":["getOrCreateEventData","events","type","eventData","get","EventData","set","constructor","this","idMap","fnMap","onceList","emitList","Map","Set","addListener","listener","once","listenerIds","listenerId","Symbol","add","_this$emitList","push","deleteListener","has","delete","size","deleteListeners","Emitter","_events","on","off","undefined","clear","emit","args","listeners","values","i","l","length","onceListeners","UniqueEmitter","data","cachedListeners"],"mappings":"AAEA,SAASA,EAAqBC,EAAmCC,GAC/D,IAAIC,EAAYF,EAAOG,IAAIF,GAK3B,OAJKC,IACHA,EAAY,IAAIE,EAChBJ,EAAOK,IAAIJ,EAAMC,IAEZA,EAGT,MAAME,EAMJE,cAAAC,KALAC,WAKA,EAAAD,KAJAE,WACAC,EAAAA,KAAAA,cACAC,EAAAA,KAAAA,cAGE,EAAAJ,KAAKC,MAAQ,IAAII,IACjBL,KAAKE,MAAQ,IAAIG,IACjBL,KAAKG,SAAW,IAAIG,IACpBN,KAAKI,SAAW,KAGlBG,YAAYC,EAAyBC,SAEnC,IAAIC,EAAcV,KAAKE,MAAMN,IAAIY,GAG5BE,IACHA,EAAc,IAAIJ,IAClBN,KAAKE,MAAMJ,IAAIU,EAAUE,IAK3B,MAAMC,EAAaC,SAgBnB,OAbAF,EAAYG,IAAIF,GAChBX,KAAKC,MAAMH,IAAIa,EAAYH,GAGvBC,GACFT,KAAKG,SAASU,IAAIF,GAMpB,OAAAG,EAAAd,KAAKI,WAALU,EAAeC,KAAKP,GAEbG,EAGTK,eAAeL,GACb,IAAKX,KAAKC,MAAMgB,IAAIN,GAAa,OAEjC,MAAMH,EAAWR,KAAKC,MAAML,IAAIe,GAC1BD,EAAcV,KAAKE,MAAMN,IAAIY,GAEnCR,KAAKG,SAASe,OAAOP,GACrBX,KAAKC,MAAMiB,OAAOP,GAClBD,EAAYQ,OAAOP,GAEdD,EAAYS,MACfnB,KAAKE,MAAMgB,OAAOV,GAGpBR,KAAKI,SAAW,KAGlBgB,gBAAgBZ,GACd,MAAME,EAAcV,KAAKE,MAAMN,IAAIY,GACnC,GAAKE,EAAL,CAEA,IAAK,MAAMC,KAAcD,EACvBV,KAAKG,SAASe,OAAOP,GACrBX,KAAKC,MAAMiB,OAAOP,GAGpBX,KAAKE,MAAMgB,OAAOV,GAClBR,KAAKI,SAAW,OAIPiB,MAAAA,EAGXtB,cAAAC,KAFUsB,aAEV,EACEtB,KAAKsB,QAAU,IAAIjB,IAGrBkB,GAA8B7B,EAAiBc,GAC7C,OAAOhB,EAAqBQ,KAAKsB,QAAS5B,GAAMa,YAAYC,GAG9DC,KAAgCf,EAAiBc,GAC/C,OAAOhB,EAAqBQ,KAAKsB,QAAS5B,GAAMa,YAAYC,GAAU,GAGxEgB,IACE9B,EACAc,GAGA,QAAaiB,IAAT/B,EAEF,YADAM,KAAKsB,QAAQI,QAKf,QAAiBD,IAAbjB,EAEF,YADAR,KAAKsB,QAAQJ,OAAOxB,GAKtB,MAAMC,EAAYK,KAAKsB,QAAQ1B,IAAIF,GAC9BC,IAImB,mBAAba,EACTb,EAAUyB,gBAAgBZ,GAI1Bb,EAAUqB,eAAeR,GAItBb,EAAUM,MAAMkB,MACnBnB,KAAKsB,QAAQJ,OAAOxB,IAIxBiC,KAAgCjC,KAAoBkC,GAClD,MAAMjC,EAAYK,KAAKsB,QAAQ1B,IAAIF,GACnC,IAAKC,EAAW,OAEhB,MAAMM,MAAEA,EAAFE,SAASA,GAAaR,EAG5B,IAAKM,EAAMkB,KAAM,OAOjB,MAAMU,EAAYlC,EAAUS,UAAY,IAAIH,EAAM6B,UAIlD,GAAI3B,EAASgB,KAGX,GAAIhB,EAASgB,OAASlB,EAAMkB,KAC1BnB,KAAKsB,QAAQJ,OAAOxB,QAIpB,IAAK,MAAMiB,KAAcR,EACvBR,EAAUqB,eAAeL,QAM7BhB,EAAUS,SAAWyB,EAMvB,IAAIE,EAAI,EACJC,EAAIH,EAAUI,OAClB,KAAOF,EAAIC,EAAGD,IACZF,EAAUE,MAAOH,IC3KvB,SAASpC,EAAqBC,EAAmCC,GAC/D,IAAIC,EAAYF,EAAOG,IAAIF,GAS3B,OARKC,IACHA,EAAY,CACVkC,UAAW,IAAIvB,IACf4B,cAAe,IAAI5B,IACnBF,SAAU,MAEZX,EAAOK,IAAIJ,EAAMC,IAEZA,EAGIwC,MAAAA,EAGXpC,mBAFUuB,aAEV,EACEtB,KAAKsB,QAAU,IAAIjB,IAGrBkB,GAA8B7B,EAAiBc,GAC7C,MAAMqB,UAAEA,EAAFzB,SAAaA,GAAaZ,EAAqBQ,KAAKsB,QAAS5B,GAKnE,OAJKmC,EAAUZ,IAAIT,KACjBqB,EAAUhB,IAAIL,GACN,MAARJ,GAAAA,EAAUW,KAAKP,IAEVA,EAGTC,KAAgCf,EAAiBc,GAC/C,MAAMqB,UAAEA,EAAFK,cAAaA,EAAb9B,SAA4BA,GAAaZ,EAAqBQ,KAAKsB,QAAS5B,GAMlF,OALKmC,EAAUZ,IAAIT,KACjBqB,EAAUhB,IAAIL,GACd0B,EAAcrB,IAAIL,GAClB,MAAAJ,GAAAA,EAAUW,KAAKP,IAEVA,EAGTgB,IAA+B9B,EAAkBc,GAC/C,QAAaiB,IAAT/B,EAEF,YADAM,KAAKsB,QAAQI,QAIf,QAAiBD,IAAbjB,EAEF,YADAR,KAAKsB,QAAQJ,OAAOxB,GAItB,MAAMC,EAAYK,KAAKsB,QAAQ1B,IAAIF,GAC9BC,IAELA,EAAUkC,UAAUX,OAAOV,GAC3Bb,EAAUuC,cAAchB,OAAOV,GAC/Bb,EAAUS,SAAW,KAEhBT,EAAUkC,UAAUV,MACvBnB,KAAKsB,QAAQJ,OAAOxB,IAIxBiC,KAAgCjC,EAAiB0C,GAC/C,MAAMzC,EAAYK,KAAKsB,QAAQ1B,IAAIF,GACnC,IAAKC,EAAW,OAEhB,MAAMkC,UAAEA,EAAFK,cAAaA,EAAb9B,SAA4BA,GAAaT,EAE/C,IAAKkC,EAAUV,KAAM,OAErB,MAAMkB,EAAkBjC,GAAY,IAAIyB,GAExC,GAAIK,EAAcf,KAChB,GAAIe,EAAcf,OAASU,EAAUV,KACnCnB,KAAKsB,QAAQJ,OAAOxB,OACf,CACL,IAAK,MAAMc,KAAY0B,EACrBL,EAAUX,OAAOV,GAEnB0B,EAAcR,QACd/B,EAAUS,SAAW,UAGvBT,EAAUS,SAAWiC,EAGvB,IAAIN,EAAI,EACJC,EAAIK,EAAgBJ,OACxB,KAAOF,EAAIC,EAAGD,IACZM,EAAgBN,GAAGK"}